## Getting the code
Fork to your directory the code here: https://github.com/ivovtin/SimLYSO<br />
Clone it locally:<br />
git clone https://github.com/[YOURNAME]/SimLYSO <br />
You should create your own branch, then do pull requests when you are done. <br />

Запуск моделирования:
====================
Нужно настроить среду Geant4-10.3.2 <br />
Сборка в SimLYSO_build: <br />
ccmake ../              <br />
жмем продолжить и сгенерировать <br />
make <br />

- ./SimLYSO input.mac <br />
Зависимые макросы input.mac->energyRun_mu.mac->allRallRun.mac <br />

./SimLYSO <br />

для визуализации редактируем visualization.mac <br />

- Start tasks on batch system: <br />
  ./run_batch.sh


Particle Species |  Color    | <br />
=============================| <br />
"gamma"          | "green"   | <br />
"e-"             | "red"     | <br />
"e+"             | "blue"    | <br />
"pi+"            | "magenta" | <br />
"pi-"            | "magenta" | <br />
"proton"         | "cyan"    | <br />
"neutron"        | "yellow"  | <br />
"other"          | "gray"    | <br />
=============================| <br />


Информация по GEANT4:
====================

G4RunManager - объект управляет процессом моделирования
В число этих классов входят как обязательные:

    G4VUserDetectorConstruction - определение геометрии установки, и, обычно, определение используемых материалов и назначение чувствительных областей;
    G4VPhysicsList - подключающий моделирование интересующих физических процессов;
    G4VUserPrimaryGeneratorAction - описывающий источник первичных частиц в моделировании; 

так и необязательные классы, без которых моделирование возможно: G4UserRunAction, G4UserEventAction и G4UserSteppingAction, позволяющие модифицировать поведение GEANT4 на том или ином этапе моделирования. 

Определение каждого класса помещается в соответствующий отдельный файл, а в главном файле проекта ExampleG4.cc происходит сведение всего воедино и регистрация классов в G4RunManager. 

Далее следует определение класса RunAction, который наследуется от класса G4UserRunAction и содержит функцию-член BeginOfRunAction, которая автоматически вызывается в начале каждого запуска. Здесь она просто выводит на экран порядковый номер запуска (0, 1 и т. д.). 

В Си++ main() является основной функцией программы, с которой начинается ее выполнение. Здесь происходит инициализация GEANT4 и все остальные вспомогательные действия.

Установка экземпляра класса SteppingVerbose, который отвечает за печать подробной информации о каждом шаге частиц в процессе моделирования. Степень детализации выводимой информации зависит от числового параметра /stepping/verbose в файле vis.mac, 0 соответствует минимально подробной, а 9 максимально подробной информации о каждом шаге. Класс SteppingVerbose определен в файлах SteppingVerbose.hh и SteppingVerbose.cc. Оператор new создает объект — экземпляр этого класса и возвращает указатель на созданный объект.

       G4VSteppingVerbose::SetInstance(new SteppingVerbose);

Настройка генератора случайных чисел. По умолчанию он возвращает одну и ту же последовательность случайных чисел, что удобно при отладке. Для генерирования более случайных последовательностей требуется задавать так называемое зерно (seed), которое в данном случае задается как сумма текущего времени в секундах и программного идентификатора. Это дает достаточно удовлетворительную случайность.

       CLHEP::HepRandom::setTheSeed(time(0)+getpid());

Далее создается объект G4RunManager, который управляет запуском и остановкой моделирования.

       G4RunManager * runManager = new G4RunManager;

Создается объект DetectorConstruction (см. класс DetectorConstrucion в файле DetectorConstruction.hh) и регистрируется в G4RunManager.

       DetectorConstruction* detector_c = new DetectorConstruction;
       runManager->SetUserInitialization(detector_c);

Так же создается и регистрируется в G4RunManager пакет физических процессов PhysicsList (см. соответствующие файлы).

       G4VUserPhysicsList *p = new PhysicsList;
       runManager->SetUserInitialization(p);

Создается и инициализируется объект класса G4VisExecutive, который позволяет различными способами визуализировать моделирование.

       G4VisManager* visManager = new G4VisExecutive;
       visManager->Initialize();
      
       runManager->SetUserAction(new PrimaryGeneratorAction);
       runManager->SetUserAction(new RunAction);  
       runManager->SetUserAction(new EventAction);
       runManager->SetUserAction(new SteppingAction);

В конце концов вызывается метод G4RunManager::Initialize() и процесс инициализации GEANT4 завершается.

       runManager->Initialize();

Печать информации о зарегистрированных материалах.

       cout<<"===============================================================";
       cout<<endl;
       cout<< *(G4Material::GetMaterialTable()) << endl;
       cout<<"===============================================================";
       cout<<endl;


Через объект класса G4UImanager производится выполнение макрокоманд из файла vis.mac (на него указывает определенная выше переменная macros). Это удобно, потому что при изменении vis.mac не нужно перекомпилировать всю программу. В vis.mac находятся команды, непосредственно запускающие моделирование.

       G4UImanager * UI = G4UImanager::GetUIpointer();  
       G4UIsession * session = new G4UIterminal();      
       UI->ExecuteMacroFile(macros);

Моделирование закончено. Освобождается память и программа завершается.

       delete session;
       delete visManager;
       delete runManager;
       return 0;
   }


В GEANT4 все используемые в моделировании физические процессы должны быть заранее подключены. Делается это в классе PhysicsList, то есть пакет физики. В нем должны создаваться определения всех частиц и для каждой частицы должны выбираться процессы, которые с ней могут происходить. Но так как создание такого пакета вручную довольно сложное дело, где надо учесть массу деталей, обычно используются готовые пакеты. В данном примере это так называемый стандартный PhysicsList, используемый в большинстве программ на GEANT4. Он включает в себя следующие процессы: для фотонов

    фотоэффект;
    комптоновское рассеяние;
    рождение пар. 


Для электронов, позитронов и мюонов:

    тормозное излучение;
    множественное рассеяние;
    ионизация среды;
    аннигиляция с античастицами. 


Кроме того для всех типов частиц подключается процесс Transportation, отвечающий за перемещение частиц в пространстве с учетом влияния магнитного поля.

Код класса PhysicsList находится в файлах PhysicsList.hh и PhysicsList.cc. Он совершенно стандартный, и единственный параметр, который в нем может потребоваться изменить — это так называемый кат. Он задается в PhysicsList.cc:

   PhysicsList::PhysicsList():  G4VUserPhysicsList()
   {
     defaultCutValue = .1*cm;
      SetVerboseLevel(1);
   }

Как видно, это величина с размерностью длины. Смысл ее таков: для каждого типа частиц — электронов, фотонов и т. д.,— и для каждого материала вычисляется энергия, при которой эта величина совпадает со средним пробегом в данной среде. Затем, в ходе моделирования, если на некотором шаге должна родиться вторичная частица, но ее энергия меньше, чем энергия ката, то эта частица не рождается, а считается поглощенной в среде в данной точке. При этом ее энергия добавляется к TotalEnergyDeposit. 


PrimaryGeneratorAction отвечает за создание первичной частицы, с которой начинается процесс моделирования события. Первичной частицей может быть электрон из ускорителя, фотон, излученный из радиоактивного источника, или вообще любая другая частица.









